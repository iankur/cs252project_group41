[u'CS 201: Mathematics for Computer Science - I', u'Pre-requisites: None', u'Units: 3-0-0-9', u'\nMathematical proofs, proofs by induction, by contradiction, proving the contrapositive.\nBasic counting techniques, pigeon-hole principle, recurrence  relations, generating functions, principle of inclusion and exclusion,  Mobius inversion.\nGraphs, trees - definitions. Connectivity, paths, cycles, Eulerian  walks, Hamiltonian cycles, cliques, colourings, graph matching,  planarity.\nDiscrete probability. Sample space, events, probability - basic  laws, discrete random variable, expectation, linearity of expectation,  independence, conditioning, Bayes theorem, Bernoulli, binomial and  geometric distributions, moments and deviations, Markov, Tchebyshev\xe2\u20ac\u2122s  inequalities, Chernoff bounds.\nApplication of probabilistic methods in combinatorics and graph theory.']
[u'CS 202: Mathematics for Computer Science - II', u'Pre-requisites: None', u'Units: 3-0-0-9 (modular second half)', u'\nPropositional logic syntax and semantics.\nTautologies, axiom system and deduction.\nProof of soundness and completeness.\nFirst order logic syntax and semantics.\nStructures, models, satisfaction and validity.\nAxiomatization, soundness and completeness.\nOptional: some advanced topics.']
[u'CS 203: Mathematics for Computer Science - III', u'Pre-requisites: None', u'Units: 3-0-0-9 (modular first half)', u'\nGroup theory: definition of groups, cosets and Lagrange\xe2\u20ac\u2122s theorem,  subgroups, normal subgroups, quotient groups, group action and  Burnside\xe2\u20ac\u2122s lemma.\nRings, Fields, integral domains - basic definitions and properties.  Field extensions, Chinese remaindering over integers and polynomial  rings. (optional: Introduction to finite fields.)']
[u'CS 210: Data Structures and Algorithms', u'Pre-requisites: ESC101', u'Units: 3-0-3-12', u'\nRandom-access-machine model, concept of problem size, and asymptotic behaviour of time/space complexity.\nEstimation of time/space complexity by smooth functions and order notations.\nA simple example of worst-case time/space complexity analysis.\nElementary data-structures: arrays, lists, queues, stacks and their applications.\nBinary search algorithm, binary trees, binary-search-tree data-structure.\nBalanced binary-search-tree: Red-Black trees.\nHashing for insert, search, delete.\nHeap data structure.\nEfficient data structures, apart from those in items 6,7, and 8, for sets with the following group of operations:']
[u'CS 220: Computer Organisation', u'Pre-requisites: ESC101, ESC201', u'Units: 3-0-3-12', u'\nIntroduction.\nArithmetic algorithms.']
[u'CS 251: Computing Laboratory - I', u'Pre-requisites: ESC101', u'Units: 0-0-3-3', u'\nBasic operating system commands. Students are expected to know the  basic shell (e.g., bash) commands and should be able to understand the  options and functioning of a command by reading the man and info pages.\nEditors. Again, students are expected to be familiar with at least  one of the two editors vim and emacs. However, they should be able to  utilize the multiple features of the editors (such as automatic  indentation, context-sensitive colouring, letype-sensitive auto-wrap,  etc.) and not use them simply as a typewriter.\nVersion control. Students will need to completely know how at least  one of the version control systems (e.g., cvs, svn, git, darcs) work.  They should be able to check in, check out, resolve errors and put tags  on a snapshot. On all subsequent assignments, they must use a form of  version control.\nScripting and automation. Of the various types of shells (bash, csh,  tcsh, ksh), the preferred choice is bash, although students should be  familiar with the different command syntax in other shells as well.  Also, they will need to know the various functions (e.g., seq, for) that  a shell provides. The choice of the scripting language (perl or python)  is open to students.\nDocument preparation. Students will learn using latex for preparing  documents. They should also know how to format properly the equations,  gures, tables, theorems, etc. using different packages and options. For  bibliography management, they should use bibtex, and must use it within  the latex documents. For drawing figures and graphs, they can choose to  learn some or all of the different softwares used popularly (they  include gnuplot, xfig, etc.).\nHardware. Students will work hands-on to learn how to install hard  drives, RAM, etc., and in general, assemble a computer from its  different parts.\nWeb applications. Students will need to know the different web  languages (html, xml) that are used along with the scripting languages  (php, javascript), forms and database tools (MySQL) that are necessary  for setting up a website. Students should be able to setup a wiki site  as well.\nUseful Application Software. Students should learn to effectively  use various softwares that serve a whole range of applications. These  include the general purpose octave or scilab, the more statistically  oriented R and the image manipulator gimp.\nOperating system installation and packages Students can choose a  particular distribution of Linux (e.g., Fedora, Debian, Ubuntu, etc.)  and learn installing the basic operating system and different packages.  They should also learn how to congure options globally (including  booting) and for particular users only. They will further understand how  to debug problems using the log and error les.']
[u'CS 252: Computing Laboratory - II', u'Pre-requisites: ESC101, CS251', u'Units: 0-0-3-3', u'\nSystem administration: Students will learn to setup and manage a  network server including a web server and an email server. They should  also be familiar with various network protocols. Further, students will  be able to administer different components of the system by using  various monitoring tools. They should also learn simple load-balancing  tools.\nSecurity: While setting up different network and  database servers, students will learn to manage the security issues  including different attacks. Public key infrastructure (PKI) is a good  example of how to setup, manage, and distribute certicates that are  issued as authorization tools. As part of maintaining sys- tems,  students will need to use system vulnerability and intrusion testing  tools as well.\nCompiler tools: Students will need to learn the various low-level tools used routinely in compilers including lex and yacc.\nProgramming environment tools: For efcient  programming, students are expected to use various integrated development  environments (IDEs) such as eclipse and debuggers such as gdb. They  should also use tools for effective tagging and browsing of source code.  Finally, they will learn to use the build tools that are necessary for  large software projects.']
"[u'CS 300: Technical Communication', u'Pre-requisite: None', u'Units: 0-0-2-2', u""\nTechnical writing\nEditing your own work\nCritiquing others' work, mentoring\nPreparing and making presentations""]"
[u'CS 315: Principles of Database Systems', u'Pre-requisites: ESC101, CS210, CS330', u'Units: 3-0-0-9', u'\nIntroduction: Database applications, purpose, accessing and  modifying databases, need for transactions, architecture - users and  administrators, data mining, information retrieval. iRelational  Databases: relational model, database schema, keys, relational query  languages, algebra, tuple and domain calculus example queries,  (optional: equivalence of relational calculus and relational algebra).\nSQL: Data definition, basic SQL query structure, set operations,  nested subqueries, aggregation, null values, database modification, join  expressions, views.\nDatabase Design: E-R model, E-R diagram, reduction to relational  schema, E-R design issues, database integrity, specifying integrity  constraints in SQL: unique columns, foreign key, triggers.\nRelational Database Design: features of good design, Functional  Dependency theory, decomposition using functional dependency and normal  forms, algorithms for decomposition, normal forms, (optional:  multi-valued dependency and 4th normal form).\nStorage and File structure: Overview of secondary storage, RAID  and flash storage. Storing tables: row-wise, column database, database  buffer. Indexing: concepts, clustered and non-clustered indices, B+-tree  indices, multiple key access, hashed files, linear hash files, bitmap  indices, Index definition in SQL, ++R-trees.\nQuery Processing: Overview, measures of query cost, selection,  sorting, join processing algorithms-nested loops, merge-sort, hash join,  aggregation.\nQuery Optimization: purpose, transformation of relational  expressions, estimating cost and statistics of expression, choosing  evaluation plans, linear and bushy plans, dynamic programming  algorithms.\nTransactions: Concept and purpose, ACID properties and their  necessity, transactions in SQL. Problems with full isolation and levels  of isolation.\nConcurrency Control: lock-based protocols, 2-phase locking,  deadlock handling, multiple granularity, timestamp based protocols,  index locking, (optional: validation protocols, multi-version protocols,  snap shot isolation, predicate locking, concurrency control for index  structures).\nRecovery: Failures and their classification, recovery and  atomicity, recovery algorithms, Undo-Redo with write ahead logging, no  Undo no Redo and other combinations, buffer management, (optional: ARIES  recovery).']
[u'CS 330: Operating Systems', u'Pre-requisites: ESC101, CS210, CS220', u'Units: 3-0-3-12', u'\nIntroduction: review of computer organization, intoduction to  popular operating systems like UNIX, Windows, etc., OS structure, system  calls, functions of OS, evolution of OSs.\nComputer organization interface: using interrupt handler to pass control between a running program and OS.\nConcept of a process: states, operations with examples from UNIX  (fork, exec) and/or Windows. Process scheduling, interprocess  communication (shared memory and message passing), UNIX signals.\nThreads: multithreaded model, scheduler activations, examples of threaded programs.\nScheduling: multi-programming and time sharing, scheduling  algorithms, multiprocessor scheduling, thread scheduling (examples using  POSIX threads).\nProcess synchronization: critical sections, classical two process  and n-process solutions, hardware primitives for synchronization,  semaphores, monitors, classical problems in synchronization  (producer-consumer, readers-writer, dining philosophers, etc.).\nDeadlocks: modeling, chararcterization, prevention and avoidance, detection and recovery.\nMemory management: with and without swapping, paging and  segmentation, demand paging, virtual memory, page replacement  algorithms, working set model, implementations from operating systems  such as UNIX, Windows. Current Hardware support for paging: e.g.,  Pentium/ MIPS processor etc.\nSecondary storage and Input/Output: device controllers and device  drivers, disks, scheduling algorithms, file systems, directory  structure, device controllers and device drivers, disks, disk space  management, disk scheduling, NFS, RAID, other devices. operations on  them, UNIX FS, UFS protection and security, NFS.\nProtection and security: Illustrations of security model of UNIX and other OSs. Examples of attacks.\nEpilogue: Pointers to advanced topics (distributed OS, multimedia  OS, embedded OS, real-time OS, OS for multiprocessor machines).']
